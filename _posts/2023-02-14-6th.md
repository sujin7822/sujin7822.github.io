---
layout: posts
title:  "2023-02-14 스터디 블로그 5!!"
---

# OCR 손글씨 인식 프로젝트

AI HUB에 주어진 대용량 손글씨 OCR 데이터를 바탕으로 NAVER GLOVA의 CRAFT모델과 SWIM-Transformer모델을 분석하고자한다.

이런 활동에 앞서 아직 CNN이 처음이기에 CNN부터 공부하기로한다.

이번 스터디는 혼자공부하는 머신러닝 유튜브를 참고하면서 진행했다.

# 밀집층
입력 특성이 1차원으로 펼쳐져있고 각 특성에 뉴런의 가중치(w)를 곱하고 절편 더해서 1개의 출력 만든다.
![image](https://user-images.githubusercontent.com/122075306/218789055-bc8201dd-f555-41b9-9a8d-2fcf5a26bbd2.png)

이미지는 2차원이기에 이를 1차원으로 펼쳐서 하는 것이 비효율적이다.

처리방식도 2차원을 유지하면서 진행하는 것이 더 좋을 듯 하다.

## 이런 것을 구현해 주는 것이 합성곱이다.
# 1차원 합성곱
합성곱을 일단 1차원으로 생각해보면,
밀집층과 다르게 뉴런(가중치)의 개수가 입력 전체에 대응하지 않고 일부만 있다. 

밑의 그림의 예는 가중치 3개만 사용한 것을 볼 수 있다. 이렇게 각 특성에 뉴런의 가중치를 곱하고 절편을 더해 1개의 출력을 만든다. 그리고 한 칸 아래로 이동하여 다시 가중치를 곱하고 절편을 더해서 또 하나의 출력을 만든다.

이렇게 전체 입력 개수 10개의 가중치를 만드는 것이 아니라 설정된 가중치를 이용하여 슬라이딩해 출력하는 것이 합성곱 이다.
![image](https://user-images.githubusercontent.com/122075306/218789397-be6ac8c0-4355-4843-ba0c-c9036802d0ce.png)

사진을 보면, 10개의 입력이 있는데 출력은 8개만 만들어진다.

합성곱에서는 뉴런의 가중치라는 말보다는 필터(커널)이라고 부른다.
# 2차원 합성곱
2차원 합성곱은 2차원 이미지를 2차원 커널을 이용하는 방식이다.
![image](https://user-images.githubusercontent.com/122075306/218790277-9e3c6a8b-f082-4d77-968b-a25df55b0ce1.png)

사진을 보면, 4x4 이미지를 3x3 커널을 사용하여 합성곱을 한 것이다. 이렇게 되면 출력의 개수는 4개가 된다.
# 특성맵
이렇게 만들어진 합성곱 연산의 출력을 특성맵이라고 부른다. 위의 사진에서 4개의 출력이 발생했으므로 2x2 특성맵이 만들어진다. 이 과정에서 활성화 함수가 사용되므로 활성화출력이라고 부른다.

합성곱에서 하나의 필터만 사용하는 것이 아니다. 필터마다 가중치도 다 다르다.
![image](https://user-images.githubusercontent.com/122075306/218790388-c071fbbe-7ec5-4715-b1e7-f628feb0afc3.png)

필터 3개를 이용하였기에 (2,2,3) 이렇게 3차원 특성맵이 만들어진다. 

합성곱 층을 만들 때,

![image](https://user-images.githubusercontent.com/122075306/218790479-7f871fc8-fa0d-422e-8454-b4e6143d5971.png)

첫 번째 10은 필터 개수이고, 커널의 크기는 3x3이렇게 코드를 구현할 수 있다.
커널의 크기가 크면, 특징을 감지하는데 효과가 떨어진다.
# 패딩
덧붙이는 것을 의미한다. 주변에 1개의 픽셀을 덧붙이는 것이다. 0으로된 가상의 픽셀을 붙여 필터가 슬라이딩하는 위치를 더 늘려준다. 
![image](https://user-images.githubusercontent.com/122075306/218790672-0df63fe8-a2ef-4443-8612-b591a28c9810.png)

사진처럼 2x2였던 특성맵이 패딩으로 4x4가 됨을 볼 수 있다.

## 패딩의 목적은 픽셀마다 합성곱에 기여하는 정도를 높여주기 위함이다.
![image](https://user-images.githubusercontent.com/122075306/218790774-243e2a97-55d5-48fd-ae94-b883f5417a71.png)

위의 사진을 보면, 3이 1번만 합성곱에 기여하였지만 패딩을 이용하면 4번으로 늘어난다.

이렇게 패딩을 이용하면 주변 픽셀의 정보를 잘 감지할 수 있다.

패딩설정은

![image](https://user-images.githubusercontent.com/122075306/218790860-43e68d56-e038-4310-a50b-dbc5177afc78.png)

보통 same패딩을 많이 사용한다.
# 스트라이드
한칸씩 이동이 아닌 이동할 칸 수를 지정할 수 있다. 이동할 칸을 늘리면 특성맵의 크기는 줄어들게 된다.
![image](https://user-images.githubusercontent.com/122075306/218790950-af6c4572-49aa-4117-9bad-6f2b4834d091.png)

보통 스트라이드는 1로 설정한다.
# 풀링
특성맵을 풀링층을 사용해서 크기를 절반으로 줄인다.

![image](https://user-images.githubusercontent.com/122075306/218791037-235f9ed9-3599-4cf1-815e-b09a188bc0b4.png)

사진을 보면, 4개의 픽셀이 2x2플링을 통해 1개의 특성맵으로 압축되는 것을 볼 수 있다.

풀링은 크게 평균풀링과 최대풀링을 많이 사용한다.

평균풀링은 특성맵에 해당되는 픽셀값의 평균이고

최대풀링은 특성맵에 해당되는 픽셀값 중 가장 큰 값을 사용하는 것이다.

풀링층에는 가중치가 없다. 그냥 입력층에 있는 값을 평균내거나 최대값만 구한다.
## 최대풀링
풀링은 이미지의 사이즈를 줄이는 것이므로 풀링끼리 겹치지 않는다. 즉, 풀링의 크기는 스트라이드 크기와 동일하다.
![image](https://user-images.githubusercontent.com/122075306/218791219-7e0a9f1c-3c23-4a43-9b3c-de963b71a3ef.png)

풀링 층 코드를 보면,

![image](https://user-images.githubusercontent.com/122075306/218791281-8cc04e34-376d-4efa-b23a-de5652bb6a50.png)

풀링의 크기는 보통 2로 지정하고 스트라이드는 따로 지정하지 않아도 된다.
# 합성곱 신경망
합성곱 신경망 사진을 보면,

![image](https://user-images.githubusercontent.com/122075306/218791341-69b2c4b3-d1d2-47d7-9c32-7608a93fcbd4.png)

4x4입력에서 패딩을 추가하여 6x6으로 만들었다.

3x3필터 3개를 사용하였고 필터마다 가중치는 다르고 절편이 있다.

3x3필터로 4x4 특성맵이 생성된다. 3개의 필터가 있었기에 4x4특성맵이 3개 만들어진다.

그렇게 만들어진 3개의 특성맵을 하나로 차곡차곡 쌓는 것이 최종 특성맵이 된다. 이때 활성화 함수가 적용된다. 

이렇게 만들어진 4x4 특성맵에 2x2최대풀링을 적용하면 가로와 세로 폭이 절반으로 줄어들게 되는 2x2 특성맵이 된다. 채널은 변하지 않고 3이다. (필터가 3개였으니까)

원하는 출력값을 얻기 위해 1차원 배열로 풀어준다. 입력값이 출력층을 통과하여 최종예측을 만들어낸다.
# 3차원 합성곱
3차원 합성곱도 2차원과 비슷하다. RGB 색깔에 따른 깊이(채널)이 있다. 커널 역시 3차원이기에 만들어지는 출력은 여전히 1개이다. 
![image](https://user-images.githubusercontent.com/122075306/218791556-e8ccf994-76bc-46b1-8742-e819d4770960.png)

여러개의 필터가 있는 경우 역시 그림과 같이 나타난다.

![image](https://user-images.githubusercontent.com/122075306/218791693-b1d893e3-6971-4cc8-b3e7-9405513b17ca.png)

피드백
- CNN에 대한 기본적인 개념이해가 끝났다면 이제 모델에 대한 학습을 진행해도 될거 같다는 피드백을 받아 다음 스터디 시간까지 NAVER GLOVA의 CRAFT모델과 SWIM-Transformer모델에 대한 공부와 분석을 진행하고자한다.
